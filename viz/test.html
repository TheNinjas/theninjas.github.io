<!DOCTYPE html>
<html lang="en">
<head>
<link rel="shortcut icon" href="../img/favicon.png">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">


<title>Career Graph</title>

<!-- Bootstrap Core CSS--> 
<link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" rel="stylesheet" type="text/css">



<!-- Fonts -->
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Lora:400,700' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,300italic,400italic,700,900' rel='stylesheet' type='text/css'>


<!-- Custom Theme CSS -->
<link href="../css/portfolio.css" rel="stylesheet">
</head>

<body>


<section>
    <div class="main_container container portfolio">
        <div class="description-container textContent">
            <div class="description">

                
                <h1><span>Reingold–Tilford Tree</span></h1>

                <p style = "margin-top: 20px;">

                <span style = "padding-top: 0px;">Collapsible Reingold–Tilford Tree is used in the example below. It is a default layout which is directly available in d3.js. You can read more about the layout <span id = "hyperlink"><a target="_blank" title="" href = "https://github.com/mbostock/d3/wiki/Tree-Layout">here</a></span> and <span id = "hyperlink"><a target="_blank" title="" href = "http://bl.ocks.org/mbostock/4339083">here.</a></span></span>

                <span>The tree layout is pretty simple to use and it appear really appleasing (visually). The animations are really smooth. The spider layout that Ambitioni has currently can be changed into something like this.</span>

                <span></span>

                <span>Why this form of representation could work:</span>

                <span style="padding-left: 20px">1. The concerns about the design managing to hold the user's attention during the initial few seconds would be addressed very well.</span>

                <span style="padding-left: 20px">2. Its very playful and simple to operate.</span>

                <span style="padding-left: 20px">3. Looks visually stunning.</span>

                <span></span>

                 <span>However, to create cross linking trees <span id = "hyperlink"><a href = "#example">(example)</a></span>  would be difficult as those layouts are not pre-defined in d3.js It will have to be tweaked. I am currently trying to do it. Although its somewhat tricky. Will let you know what happens.</span>

                 <span style="font-size: 22px;"><strong>An working prototype (albeit real data) is shown below.</strong></span>

                </p>
            </div>
        </div>

      
        <div id="hey">
        </div>

        <div class="main_container container portfolio">
        <div class="description-container textContent">
            <div class="description" id="example">

            <p><span>Cross-linking tree (not a default layout of d3.js). I've just put up an image to help you understand what it would be like:</span>
            </p>

        </div></div></div>

        <div class="mainGallery container">
          <figure class="">
              <img src="../img/test.jpg" alt="" >
          </figure>
        </div>

        

    </div>
</div>
</section>


<!-- Core JavaScript Files --> 
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script> 

<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>
<!--<script type="text/javascript" src="../TEMP/bootstrap.min.js"></script>-->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-53446145-1', 'auto');
  ga('require', 'displayfeatures');
  ga('send', 'pageview');
</script>



<style>

.node {
  cursor: pointer;
}

.node circle {
  fill: #fff;
  stroke-width : 1.5px;
}

.node text {
  font: 10px sans-serif;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1px;
}

</style>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var margin = {top: 20, right: 120, bottom: 20, left: 120},
    width = 960 - margin.right - margin.left,
    height = 1000 - margin.top - margin.bottom;
    
var i = 0,
    duration = 750,
    root;

var tree = d3.layout.tree()
    .size([height, width]);

var colors = [ "#e74c3c", "#2ecc71", "#e67e22", "#1abc9c", "#16a085", "#f1c40f", "#f39c12", "#8e44ad", "#2c3e50", "#c0392b"]

var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });

var svg = d3.select("body").select("#hey").append("svg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

d3.json("cursive.json", function(error, flare) {
  root = flare;
  root.x0 = height / 2;
  root.y0 = 0;

  function collapse(d) {
    if (d.children) {
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }

  root.children.forEach(collapse);
  update(root);
});

d3.select(self.frameElement).style("height", "800px");

function update(source) {

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse(),
      links = tree.links(nodes);



  // Normalize for fixed-depth.
  nodes.forEach(function(d) { d.y = d.depth * 180; });

  // Update the nodes…
  var node = svg.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .on("click", click);

  nodeEnter.append("circle")
      .attr("r", function(d) {if (d.size/100 > 20) { return Math.floor((Math.random() * 20) + 5) } else { return d.size/100 } ; })
      .style("stroke", function(d) {
        return d._children ? "#fff" : colors[(d.size % 10)] })
      .style("fill", function(d) { return d._children ? colors[d.size % 10] : "#fff" });

  nodeEnter.append("text")
      .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
      .text(function(d) { return d.name; })
      .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("circle")
      .style("fill", function(d) { return d._children ? colors[d.size % 10] : "#fff"; })
      .style("stroke", function(d) { return d._children ? colors[d.size % 10] : colors[d.size % 10] });

  nodeUpdate.select("text")
      .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .remove();

  nodeExit.select("circle")

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the links…
  var link = svg.selectAll("path.link")
      .data(links, function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      });

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}

// Toggle children on click.
function click(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
  update(d);
}

</script>
</html>
